#!/usr/bin/env node

/**
 * fix-images.js
 *
 * Interactive CLI tool to fix both product folder mismatches and path alignment mismatches in image links.
 *
 * Usage:
 *   node scripts/fix-images.js <product-folder> [--case=product|path]
 *   (default: both cases)
 */

const fs = require('fs');
const path = require('path');
const readline = require('readline');
const { spawn } = require('child_process');

// ANSI color codes
const colors = {
  reset: '\x1b[0m',
  bold: '\x1b[1m',
  cyan: '\x1b[36m',
  yellow: '\x1b[33m',
  green: '\x1b[32m',
  gray: '\x1b[90m',
  red: '\x1b[31m',
};

function walkDir(dir, ext, fileList = []) {
  const files = fs.readdirSync(dir);
  for (const file of files) {
    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);
    if (stat.isDirectory()) {
      walkDir(fullPath, ext, fileList);
    } else if (file.endsWith(ext)) {
      fileList.push(fullPath);
    }
  }
  return fileList;
}

function findImageLinks(mdContent) {
  // Matches ![alt](path) or ![](path)
  const regex = /!\[[^\]]*\]\(([^)]+)\)/g;
  let match;
  const results = [];
  while ((match = regex.exec(mdContent)) !== null) {
    results.push({
      link: match[0],
      path: match[1],
      index: match.index,
    });
  }
  return results;
}

function getContextLines(mdContent, index, numLines = 2) {
  const lines = mdContent.split('\n');
  let charCount = 0;
  let lineNum = 0;
  for (; lineNum < lines.length; lineNum++) {
    charCount += lines[lineNum].length + 1;
    if (charCount > index) break;
  }
  const start = Math.max(0, lineNum - numLines);
  const end = Math.min(lines.length, lineNum + numLines + 1);
  return lines.slice(start, end).join('\n');
}

function promptUser(question) {
  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  return new Promise(resolve => rl.question(question, ans => { rl.close(); resolve(ans); }));
}

function openImage(filePath) {
  const platform = process.platform;
  let cmd, args;
  if (platform === 'win32') {
    cmd = 'cmd';
    args = ['/c', 'start', '""', filePath];
  } else if (platform === 'darwin') {
    cmd = 'open';
    args = [filePath];
  } else {
    cmd = 'xdg-open';
    args = [filePath];
  }
  spawn(cmd, args, { stdio: 'ignore', detached: true }).unref();
}

function getProductFolderFromImgPath(imgPath, productFolder) {
  // Count how many segments in productFolder
  const numSegments = productFolder.split('/').length;
  // Build regex to match that many segments after img/product_docs/
  const regex = new RegExp('(?:^|/)img/product_docs/((?:[^/]+/){' + (numSegments - 1) + '}[^/]+)/');
  const norm = imgPath.replace(/\\/g, '/');
  const m = norm.match(regex);
  return m ? m[1] : null;
}

function pathHasProductFolder(imgPath, productFolder) {
  // Normalize and check if productFolder is in the path after /img/product_docs/
  const norm = imgPath.replace(/\\/g, '/');
  return norm.includes('/img/product_docs/' + productFolder + '/') || norm.includes('img/product_docs/' + productFolder + '/');
}

function getExpectedImagePath(productFolder, mdFile, origImgPath) {
  // Support /img/product_docs/<productFolder>/, img/product_docs/<productFolder>/, or static/img/product_docs/<productFolder>/
  const normImgPath = origImgPath.replace(/\\/g, '/');
  const prefixes = [
    '/img/product_docs/' + productFolder + '/',
    'img/product_docs/' + productFolder + '/',
    'static/img/product_docs/' + productFolder + '/',
  ];
  const prefix = prefixes.find(p => normImgPath.startsWith(p));
  if (!prefix) return null;
  // Get the relative path of the md file (excluding filename)
  const mdRelPath = path.relative(path.join('docs', productFolder), mdFile).replace(/\\/g, '/');
  const mdRelDir = path.dirname(mdRelPath);
  const imgFileName = path.basename(normImgPath);
  const expected = prefix + (mdRelDir === '.' ? '' : mdRelDir + '/') + imgFileName;
  return expected;
}

function isProductFolderMismatch(productFolder, imgPath) {
  // True if the product folder in the image path does not match the input
  const found = getProductFolderFromImgPath(imgPath, productFolder);
  return found && found !== productFolder;
}

function isPathAlignmentMismatch(productFolder, mdFile, imgPath) {
  const normImgPath = imgPath.replace(/\\/g, '/');
  const prefixes = [
    '/img/product_docs/' + productFolder + '/',
    'img/product_docs/' + productFolder + '/',
    'static/img/product_docs/' + productFolder + '/',
  ];
  const prefix = prefixes.find(p => normImgPath.startsWith(p));
  if (!prefix) return false;
  // Get the subpath after product folder (excluding filename)
  const imgSubPath = path.dirname(normImgPath.slice(prefix.length));
  const mdRelPath = path.relative(path.join('docs', productFolder), mdFile).replace(/\\/g, '/');
  const mdRelDir = path.dirname(mdRelPath);
  // If subpath does not match mdRelDir, it's a mismatch
  return imgSubPath !== mdRelDir;
}

function getCandidateImagePaths(productFolder, mdFile, origImgPath) {
  // Suggest: <prefix>/<productFolder>/<md-file-relative-path>/<original image file name> and _1, _2, etc.
  const prefixes = [
    '/img/product_docs/',
    'img/product_docs/',
    'static/img/product_docs/',
  ];
  const prefix = prefixes.find(p => origImgPath.replace(/\\/g, '/').startsWith(p));
  if (!prefix) return [];
  const baseDir = prefix + productFolder;
  const mdRelPath = path.relative(path.join('docs', productFolder), mdFile).replace(/\\/g, '/');
  const imgFileName = path.basename(origImgPath);
  const prefixName = imgFileName.replace(/(\.[^.]+)$/, '');
  const ext = path.extname(imgFileName);
  let currDir = path.dirname(mdRelPath);
  while (true) {
    const parentDir = baseDir + (currDir === '.' ? '' : '/' + currDir);
    const parentDirFs = path.join('static', parentDir.replace(/^\/?img\//, 'img/').replace(/^\/?/, ''));
    let found = [];
    if (fs.existsSync(parentDirFs)) {
      const files = fs.readdirSync(parentDirFs);
      // Find all files matching basename and basename_#
      files.forEach(f => {
        if (
          (f === imgFileName ||
            (f.startsWith(prefixName + '_') && f.endsWith(ext) && /^_\d+/.test(f.slice(prefixName.length))))
        ) {
          found.push((parentDir + '/' + f).replace(/\\/g, '/').replace(/\/\//g, '/'));
        }
      });
    }
    if (found.length > 0) {
      // Return all matches at this level only
      return [...new Set(found)];
    }
    // If not found, check one level deeper: a subfolder named after the markdown file's base name
    if (currDir !== '.' && currDir !== '' && currDir !== path.sep) {
      const mdBaseName = path.basename(mdRelPath, path.extname(mdRelPath));
      const subDir = parentDir + '/' + mdBaseName;
      const subDirFs = path.join('static', subDir.replace(/^\/?img\//, 'img/').replace(/^\/?/, ''));
      let foundSub = [];
      if (fs.existsSync(subDirFs)) {
        const files = fs.readdirSync(subDirFs);
        files.forEach(f => {
          if (
            (f === imgFileName ||
              (f.startsWith(prefixName + '_') && f.endsWith(ext) && /^_\d+/.test(f.slice(prefixName.length))))
          ) {
            foundSub.push((subDir + '/' + f).replace(/\\/g, '/').replace(/\/\//g, '/'));
          }
        });
      }
      if (foundSub.length > 0) {
        return [...new Set(foundSub)];
      }
    }
    // Extra check for overview.md: look for image named after the last folder
    if (path.basename(mdRelPath) === 'overview.md') {
      const lastFolder = path.basename(currDir);
      if (lastFolder && lastFolder !== '.' && lastFolder !== path.sep) {
        const overviewImg = lastFolder + ext;
        const overviewImgPath = parentDir + '/' + overviewImg;
        const overviewImgFs = path.join('static', overviewImgPath.replace(/^\/?img\//, 'img/').replace(/^\/?/, ''));
        if (fs.existsSync(overviewImgFs)) {
          return [overviewImgPath.replace(/\\/g, '/').replace(/\/\//g, '/')];
        }
      }
    }
    if (currDir === '' || currDir === '.' || currDir === path.sep) break;
    currDir = path.dirname(currDir);
  }
  return [];
}

async function main() {
  const inputFolder = process.argv[2];
  const caseArg = process.argv.find(arg => arg.startsWith('--case='));
  const whichCase = caseArg ? caseArg.split('=')[1] : 'both';
  if (!inputFolder) {
    console.error('Usage: node scripts/fix-images.js <product-folder> [--case=product|path]');
    process.exit(1);
  }
  const docsRoot = path.join('docs', inputFolder);
  if (!fs.existsSync(docsRoot)) {
    console.error('Folder not found:', docsRoot);
    process.exit(1);
  }
  const mdFiles = walkDir(docsRoot, '.md');
  // Track skipped image links for this run
  const skippedLinks = new Set();
  // Collect skipped info for report
  const skippedReport = [];
  for (const mdFile of mdFiles) {
    const mdContent = fs.readFileSync(mdFile, 'utf8');
    const links = findImageLinks(mdContent);
    let newContent = mdContent;
    // Collect all changes first, then apply them in reverse order to avoid index shifting
    const changes = [];
    for (const linkObj of links) {
      const { link, path: imgPath, index } = linkObj;
      // Create a unique key for this image link in this file
      const skipKey = mdFile + '|' + link;
      if (skippedLinks.has(skipKey)) {
        continue;
      }
      let caseType = null;
      if ((whichCase === 'both' || whichCase === 'product') && isProductFolderMismatch(inputFolder, imgPath)) {
        caseType = 'product';
      } else if ((whichCase === 'both' || whichCase === 'path') && isPathAlignmentMismatch(inputFolder, mdFile, imgPath)) {
        caseType = 'path';
      } else {
        continue;
      }
      const context = getContextLines(mdContent, index, 2);
      const candidates = getCandidateImagePaths(inputFolder, mdFile, imgPath);
      let skipAndReport = false;
      if (candidates.length === 0) {
        // Automatically skip if this is a path alignment mismatch or product folder mismatch
        if (caseType === 'path' || caseType === 'product') {
          skipAndReport = true;
        }
      }
      if (skipAndReport) {
        // Collect all info for report
        let reportEntry = '';
        reportEntry += '\n---\n';
        reportEntry += `File: ${mdFile}\n`;
        reportEntry += `Context:\n${context}\n`;
        reportEntry += `Original image link: ${link}\n`;
        if (caseType === 'product') {
          reportEntry += 'Case: Product folder mismatch\n';
        } else if (caseType === 'path') {
          reportEntry += 'Case: Path alignment mismatch\n';
        }
        reportEntry += 'No suggested images found.\n';
        skippedReport.push(reportEntry);
        skippedLinks.add(skipKey);
        continue;
      }
      console.log('\n---');
      console.log(`${colors.bold}${colors.cyan}File: ${mdFile}${colors.reset}`);
      console.log(`${colors.gray}Context:`);
      console.log(context + colors.reset);
      console.log(`${colors.yellow}Original image link: ${link}${colors.reset}`);
      if (caseType === 'product') {
        console.log(`${colors.red}Case: Product folder mismatch${colors.reset}`);
      } else if (caseType === 'path') {
        console.log(`${colors.red}Case: Path alignment mismatch${colors.reset}`);
      }
      if (candidates.length === 1) {
        // Auto-update with the single candidate
        const action = candidates[0];
        let imgFsPath = action.replace(/^\//, '');
        if (!imgFsPath.startsWith('static/')) imgFsPath = 'static/' + imgFsPath;
        if (fs.existsSync(imgFsPath)) {
          // Use root-relative path for markdown
          const relImgPath = action.startsWith('/') ? action : '/' + action;
          const newLink = link.replace(imgPath, relImgPath);
          changes.push({
            originalLink: link,
            newLink: newLink,
            index: index
          });
          console.log(`${colors.green}Automatically updated image link in file with: ${action}${colors.reset}`);
        } else {
          console.log(colors.red, 'Suggested image does not exist:', imgFsPath, colors.reset);
          // Fallback to prompt if file doesn't exist
        }
      } else {
        if (candidates.length === 0) {
          console.log(colors.red, 'No suggested images found.', colors.reset);
          // Automatically skip if this is a path alignment mismatch
          if (caseType === 'path') {
            skippedLinks.add(skipKey);
            continue;
          }
        } else {
          // Print suggested images if there are multiple candidates
          console.log('Suggested image(s):');
          candidates.forEach((c, i) => {
            console.log(`  ${colors.green}[${i + 1}] ${c}${colors.reset}`);
          });
        }
        let action;
        while (candidates.length > 0 || (caseType !== 'path' && candidates.length === 0)) {
          let prompt = `\n${colors.bold}Choose an option:${colors.reset}\n`;
          if (candidates.length) prompt += '  [1-' + candidates.length + '] Select a suggested image\n';
          prompt += '  [c] Enter custom path\n  [s] Skip\n> ';
          action = await promptUser(prompt);
          if (candidates.length && /^[1-9]\d*$/.test(action) && +action >= 1 && +action <= candidates.length) {
            action = candidates[+action - 1];
          } else if (action.toLowerCase() === 'c') {
            action = await promptUser('Enter custom image path: ');
          } else if (action.toLowerCase() === 's') {
            // Mark this image link as skipped for this run
            skippedLinks.add(skipKey);
            break;
          } else {
            console.log('Invalid input.');
            continue;
          }
          // Check if file exists (relative to static/ or root)
          let imgFsPath = action ? action.replace(/^\//, '') : '';
          if (action && !imgFsPath.startsWith('static/')) imgFsPath = 'static/' + imgFsPath;
          if (action && !fs.existsSync(imgFsPath)) {
            console.log('File does not exist:', imgFsPath);
            continue;
          }
          if (action) openImage(imgFsPath);
          const confirm = await promptUser('Use this image? [y/N]: ');
          if (confirm.toLowerCase() === 'y') {
            // Use root-relative path for markdown
            const relImgPath = action.startsWith('/') ? action : '/' + action;
            const newLink = link.replace(imgPath, relImgPath);
            changes.push({
              originalLink: link,
              newLink: newLink,
              index: index
            });
            console.log('Updated image link in file.');
            break;
          } else {
            console.log('Not updating.');
          }
        }
      }
    }
    // Apply all changes in reverse order to avoid index shifting
    changes.sort((a, b) => b.index - a.index);
    for (const change of changes) {
      newContent = newContent.replace(change.originalLink, change.newLink);
    }
    if (newContent !== mdContent) {
      fs.writeFileSync(mdFile, newContent, 'utf8');
      console.log('File updated:', mdFile);
    }
  }
  // At the end of main, after all files processed, write the skipped report if any
  if (skippedReport.length > 0) {
    const imgRoot = path.join('static', 'img', 'product_docs', inputFolder);
    if (!fs.existsSync(imgRoot)) {
      fs.mkdirSync(imgRoot, { recursive: true });
    }
    const reportPath = path.join(imgRoot, 'skipped-image-links.txt');
    fs.writeFileSync(reportPath, skippedReport.join('\n'), 'utf8');
    console.log(`\nSkipped image links report written to: ${reportPath}`);
  }
  console.log('Done.');
}

main(); 